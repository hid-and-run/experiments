import sys
import struct
from collections import namedtuple
import json

packets = open(sys.argv[1]).read().strip().split("\n")

hid_keys= {
    "0x00": "KEY_NONE",
    "0x01": "KEY_ERR_OVF", 
    "0x04": "KEY_A", 
    "0x05": "KEY_B", 
    "0x06": "KEY_C", 
    "0x07": "KEY_D", 
    "0x08": "KEY_E", 
    "0x09": "KEY_F", 
    "0x0a": "KEY_G", 
    "0x0b": "KEY_H", 
    "0x0c": "KEY_I", 
    "0x0d": "KEY_J", 
    "0x0e": "KEY_K", 
    "0x0f": "KEY_L", 
    "0x10": "KEY_M", 
    "0x11": "KEY_N", 
    "0x12": "KEY_O", 
    "0x13": "KEY_P", 
    "0x14": "KEY_Q", 
    "0x15": "KEY_R", 
    "0x16": "KEY_S", 
    "0x17": "KEY_T", 
    "0x18": "KEY_U", 
    "0x19": "KEY_V", 
    "0x1a": "KEY_W", 
    "0x1b": "KEY_X", 
    "0x1c": "KEY_Y", 
    "0x1d": "KEY_Z", "0x1e":"KEY_1", 
    "0x1f": "KEY_2", 
    "0x20": "KEY_3", 
    "0x21": "KEY_4", 
    "0x22": "KEY_5", 
    "0x23": "KEY_6", 
    "0x24": "KEY_7", 
    "0x25": "KEY_8", 
    "0x26": "KEY_9", 
    "0x27": "KEY_0", "0x28":"KEY_ENTER", 
    "0x29": "KEY_ESC", 
    "0x2a": "KEY_BACKSPACE", 
    "0x2b": "KEY_TAB", 
    "0x2c": "KEY_SPACE", 
    "0x2d": "KEY_MINUS", 
    "0x2e": "KEY_EQUAL", 
    "0x2f": "KEY_LEFTBRACE", 
    "0x30": "KEY_RIGHTBRACE", 
    "0x31": "KEY_BACKSLASH", 
    "0x32": "KEY_HASHTILDE", 
    "0x33": "KEY_SEMICOLON", 
    "0x34": "KEY_APOSTROPHE", 
    "0x35": "KEY_GRAVE", 
    "0x36": "KEY_COMMA", 
    "0x37": "KEY_DOT", 
    "0x38": "KEY_SLASH", 
    "0x39": "KEY_CAPSLOCK", "0x3a":"KEY_F1", 
    "0x3b": "KEY_F2", 
    "0x3c": "KEY_F3", 
    "0x3d": "KEY_F4", 
    "0x3e": "KEY_F5", 
    "0x3f": "KEY_F6", 
    "0x40": "KEY_F7", 
    "0x41": "KEY_F8", 
    "0x42": "KEY_F9", 
    "0x43": "KEY_F10", 
    "0x44": "KEY_F11", 
    "0x45": "KEY_F12", "0x46":"KEY_SYSRQ", 
    "0x47": "KEY_SCROLLLOCK", 
    "0x48": "KEY_PAUSE", 
    "0x49": "KEY_INSERT", 
    "0x4a": "KEY_HOME", 
    "0x4b": "KEY_PAGEUP", 
    "0x4c": "KEY_DELETE", 
    "0x4d": "KEY_END", 
    "0x4e": "KEY_PAGEDOWN", 
    "0x4f": "KEY_RIGHT", 
    "0x50": "KEY_LEFT", 
    "0x51": "KEY_DOWN", 
    "0x52": "KEY_UP", "0x53":"KEY_NUMLOCK", 
    "0x54": "KEY_KPSLASH", 
    "0x55": "KEY_KPASTERISK", 
    "0x56": "KEY_KPMINUS", 
    "0x57": "KEY_KPPLUS", 
    "0x58": "KEY_KPENTER", 
    "0x59": "KEY_KP1", 
    "0x5a": "KEY_KP2", 
    "0x5b": "KEY_KP3", 
    "0x5c": "KEY_KP4", 
    "0x5d": "KEY_KP5", 
    "0x5e": "KEY_KP6", 
    "0x5f": "KEY_KP7", 
    "0x60": "KEY_KP8", 
    "0x61": "KEY_KP9", 
    "0x62": "KEY_KP0", 
    "0x63": "KEY_KPDOT", "0x64":"KEY_102ND", 
    "0x65": "KEY_COMPOSE", 
    "0x66": "KEY_POWER", 
    "0x67": "KEY_KPEQUAL", "0x68":"KEY_F13", 
    "0x69": "KEY_F14", 
    "0x6a": "KEY_F15", 
    "0x6b": "KEY_F16", 
    "0x6c": "KEY_F17", 
    "0x6d": "KEY_F18", 
    "0x6e": "KEY_F19", 
    "0x6f": "KEY_F20", 
    "0x70": "KEY_F21", 
    "0x71": "KEY_F22", 
    "0x72": "KEY_F23", 
    "0x73": "KEY_F24", "0x74":"KEY_OPEN", 
    "0x75": "KEY_HELP", 
    "0x76": "KEY_PROPS", 
    "0x77": "KEY_FRONT", 
    "0x78": "KEY_STOP", 
    "0x79": "KEY_AGAIN", 
    "0x7a": "KEY_UNDO", 
    "0x7b": "KEY_CUT", 
    "0x7c": "KEY_COPY", 
    "0x7d": "KEY_PASTE", 
    "0x7e": "KEY_FIND", 
    "0x7f": "KEY_MUTE", 
    "0x80": "KEY_VOLUMEUP", 
    "0x81": "KEY_VOLUMEDOWN", "0x85":"KEY_KPCOMMA", "0x87":"KEY_RO", 
    "0x88": "KEY_KATAKANAHIRAGANA", 
    "0x89": "KEY_YEN", 
    "0x8a": "KEY_HENKAN", 
    "0x8b": "KEY_MUHENKAN", 
    "0x8c": "KEY_KPJPCOMMA", "0x90":"KEY_HANGEUL", 
    "0x91": "KEY_HANJA", 
    "0x92": "KEY_KATAKANA", 
    "0x93": "KEY_HIRAGANA", 
    "0x94": "KEY_ZENKAKUHANKAKU", "0xb6":"KEY_KPLEFTPAREN", 
    "0xb7": "KEY_KPRIGHTPAREN", "0xe0":"KEY_LEFTCTRL", 
    "0xe1": "KEY_LEFTSHIFT", 
    "0xe2": "KEY_LEFTALT", 
    "0xe3": "KEY_LEFTMETA", 
    "0xe4": "KEY_RIGHTCTRL", 
    "0xe5": "KEY_RIGHTSHIFT", 
    "0xe6": "KEY_RIGHTALT", 
    "0xe7": "KEY_RIGHTMETA", "0xe8":"KEY_MEDIA_PLAYPAUSE",
    "0xe9": "KEY_MEDIA_STOPCD",
    "0xea": "KEY_MEDIA_PREVIOUSSONG",
    "0xeb": "KEY_MEDIA_NEXTSONG",
    "0xec": "KEY_MEDIA_EJECTCD",
    "0xed": "KEY_MEDIA_VOLUMEUP",
    "0xee": "KEY_MEDIA_VOLUMEDOWN",
    "0xef": "KEY_MEDIA_MUTE",
    "0xf0": "KEY_MEDIA_WWW",
    "0xf1": "Left Click", #KEY_MEDIA_BACK",
    "0xf2": "Middle Click", #"KEY_MEDIA_FORWARD",
    "0xf3": "Right Click", #"KEY_MEDIA_STOP",
    "0xf4": "KEY_MEDIA_FIND",
    "0xf5": "KEY_MEDIA_SCROLLUP",
    "0xf6": "Move X", #"KEY_MEDIA_SCROLLDOWN",
    "0xf7": "KEY_MEDIA_EDIT",
    "0xf8": "KEY_MEDIA_SLEEP",
    "0xf9": "KEY_MEDIA_COFFEE",
    "0xfa": "KEY_MEDIA_REFRESH",
    "0xfb": "KEY_MEDIA_CALC",
}

def decode_buttons(arr):
    btn_mapping = ["1", "3", "2", "5", "4", "7", "-", "6", "8"]
    profile_start = [0x8, 0x44, 0x50, 0x60]
    
    for profile in range(4):
        print("%% -- Profile %d --" % (profile + 1))
        for idx in range(9):
            offset = idx + profile_start[profile]
            data = struct.unpack('<B', arr[offset:(offset+1)])[0]
            code = "%02x" % data  + "??"
            if data == 0x0: code = "--"
            if data == 0x21: code = "Left click"
            if data == 0x22: code = "Middle click"
            if data == 0x23: code = "Right click"
            if data == 0x24: code = "Backward"
            if data == 0x25: code = "Forward"
            if data == 0x35: code = "LED Loop"
            if data == 0x26: code = "DPI Loop"
            if data == 0x28: code = "Double Click"
            if data == 0x2f: code = "Mute"
            if data == 0x2d: code = "[MACRO]"
            if data == 0x37: code = "-> Profile 0"
            if data == 0x38: code = "-> Profile 1"
            if data == 0x39: code = "-> Profile 2"
            if data == 0x3a: code = "-> Profile 3"
            if data == 0x2b: code = "DPI+"
            if data == 0x2c: code = "DPI-"
            print("%% Mouse button %s -> %s" % (btn_mapping[idx], code))
    return True

def decode_macros(arr, len):
    start_offset = 4 * 256
    idx = 2
    events = 0
    print("% -- Macros --")
    while(True):
        off = idx + start_offset
        data = struct.unpack('<BB', arr[off:(off+2)])
        print("%% [delay %dms]" % ((data[0] & 0x7f) * 2))
        
        if data[1] != 0xf6:
            if data[0] & 0x80: print("% [Press]")
            kn = "?"
            try:
                kn = hid_keys["0x%02x" % data[1]]
            except:
                pass
            print("%% Key %s" % kn)
        else:
            # mouse movement
            x, y = struct.unpack('<hh', arr[(off+2):(off+2+4)])
            print("%% Move [X]: %d | [Y]: %d" % (x, y))
            idx += 4

        if data[1] == 0:
            print("%% [@%d]" % (idx))
        if events >= macro_len: break
        events += 1
        idx += 2
        
def decode_macro_assignments(arr):
    profile_pos = [0xa0, 0x2c + 256, 0xb8 + 256, 0x44 + 512]
    macro_len = 0
    for profile in range(4):
        for macro in range(9):
            idx = profile_pos[profile] + macro * 10
            data = struct.unpack('<BBBBBBBBBB', arr[idx:(idx+10)])
            length = data[1]
            start = data[5]
            if data[0] == 0: continue
            print("%% profile %d: macro for key %d (%d events) starts @ %d" % (profile, macro, length, start))
            print(data)
            macro_len = max(macro_len, length)
    return macro_len


def decode_leds(arr):
    
    return True

known_ranges = {
  "00": {
    "profile1_buttons": [decode_buttons, 0x8, 0x8 + 9],
    "profile2_buttons": [decode_buttons, 0x44, 0x44 + 9],
    "profile3_buttons": [decode_buttons, 0x50, 0x50 + 9],
    "profile4_buttons": [decode_buttons, 0x60, 0x60 + 9],
    "profile1_macro_assignments": [decode_macro_assignments, 0xa0, 90]
  },
  "01": {
    "profile2_macro_assignments": [decode_macro_assignments, 0x2c, 0x2c + 90],
    "profile3_macro_assignments": [decode_macro_assignments, 0xb8, 0xb8 + 90],
  }, 
  "02": { 
    "profile3_macro_assignments_ff": [decode_macro_assignments, 0x00, 0x12],
    "profile4_macro_assignments": [decode_macro_assignments, 0x44, 0x44 + 90],
  },
  "03": { },
  "04": { 
      "macros": [decode_macros, 0x0, 0x1000]
  }
}


def decode(packet, state):
    if not packet.startswith("0718") or len(packet) != 16:
        print("Error: invalid packet %s" % packet)
        return False
    packet = packet[4:]
    cmd = packet[0:2]
    index = packet[2:4]
    offset = packet[4:6]
    unknown = packet[6:8]
    page = packet[6:8]
    data = packet[8:10]
    end = packet[10:12]
    data_val = int(data, 16)
    #print("%s -> %s" % (packet, cmd))
    
    pos = int(offset, 16) + int(index, 16)
    
    if packet == "030001000300" or packet == "030001000300":
        print("Start of programming")
        return True
    
    if packet == "100000000000" or packet == "000000000000":
        print("End of programming")
        return True
    
    if packet == "000001000000":
        print("Configure keys start")
        state["in_configurekeys"] = True
        return True
    
    if packet == "050076000000":
        print("Configure keys end")
        state["in_configurekeys"] = False
        return True
    
    if cmd == "03": # write to page
        state["page"][int(page, 16)][pos] = data_val
        state["raw_data"][pos + int(page, 16) * 256] = data_val
        
        for rng in known_ranges[page].keys():
            if pos >= known_ranges[page][rng][1] and pos <= known_ranges[page][rng][2]:
                if state["current_range"] != rng:
                    print("* [%s] *" % rng)
                    state["current_range"] = rng
                return True

        #if data_val != 0: 
        print("Index %s, Offset %s, Page %s, Data %s, End %s" % (index, offset, unknown, data, end))
        return True
    
    if cmd == "09": # block end
        #print("Block %s end? End: %s" % (offset, end))
        return True
    
    if cmd == "00": # block finalze
        #print("Block %s finalize? End: %s" % (offset, end))
        return True

    print("Unknown: %s" % packet)
    return False
    

state = {
    "in_macro": False,
    "macroarray": [0] * 1024,
    "keyarray": [0] * 1024,
    "in_configurekeys": False,
    "current_range": None,
    "page": [
        [0] * 256,
        [0] * 256,
        [0] * 256,
        [0] * 256,
        [0] * 256
    ],
    "raw_data": [0] * 256 * 5
}

for packet in packets:
    decode(packet, state)
        
memory = state["page"][0] + state["page"][1] + state["page"][2] + state["page"][3] + state["page"][4]
decode_buttons(bytearray(memory))
macro_len = decode_macro_assignments(bytearray(memory))
if macro_len != 0:
    decode_macros(bytearray(memory), macro_len)

print(state["raw_data"])
f = open("dump.bin", "wb")
f.write(bytearray(state["raw_data"]))
f.close()
