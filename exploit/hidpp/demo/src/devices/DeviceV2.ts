import { HIDppDevice } from "./Device";
import { uint8, HIDpp2Report } from "../types/types";
import {
  toUint8,
  toReportId,
  reportId,
  toHex,
  MOD_TO_HID,
  parseMod,
  parseKey,
  crc_ccitt,
} from "../types/utils";

class HIDpp2Device extends HIDppDevice {
  private async receiveReport(): Promise<HIDpp2Report> {
    let [reportId, arr] = await this.receive();
    if (arr[1] === 0xff && arr[4] !== 0x00) {
      let error_codes: any = {
        1: "UNKNOWN",
        2: "INVALID_ARGUMENT",
        3: "OUT_OF_RANGE",
        4: "HW_ERROR",
        5: "LOGITECH_INTERNAL",
        6: "INVALID_FEATURE_INDEX",
        7: "INVALID_FUNTION_ID",
        8: "BUSY",
        9: "UNSUPPORTED",
      };
      console.error(
        `[ERROR ON DEVICE] ${
          arr[4] in error_codes ? error_codes[arr[4]] : "UNKOWN_ERROR"
        }`
      );
    }
    let func: HIDpp2Report = {
      reportId: toReportId(reportId),
      deviceIndex: toUint8(arr[0]),
      featureIndex: toUint8(arr[1]),
      functionId: toUint8(arr[2] >> 4),
      params: Array.from(arr.slice(3)).map((x) => toUint8(x)),
    };
    return func;
  }

  private async sendReport(func: HIDpp2Report) {
    if (
      (func.reportId === reportId.SHORT && func.params.length !== 3) ||
      (func.reportId === reportId.LONG && func.params.length !== 16)
    ) {
      throw new TypeError("Parameters and reportId do not match!");
    }
    await this.send(
      func.reportId,
      Uint8Array.from([
        func.deviceIndex,
        func.featureIndex,
        toUint8((func.functionId << 4) | 0x0a),
        ...func.params,
      ])
    );
  }

  // TODO: is this useful?
  private async getFeatureId(index: number): Promise<uint8> {
    await this.sendReport({
      reportId: reportId.SHORT,
      deviceIndex: this.deviceIndex,
      featureIndex: 0x01,
      functionId: 0x01,
      params: [toUint8(index), 0x00, 0x00],
    });
    let response = await this.receiveReport();
    if (response.params[0] === 0 && response.params[1] === 0) {
      throw new Error(`No feature mapped at index ${index}!`);
    }
    return response.params[1];
  }

  private async getFeatureIndex(id: number): Promise<uint8> {
    await this.sendReport({
      reportId: reportId.SHORT,
      deviceIndex: this.deviceIndex,
      featureIndex: 0x00,
      functionId: 0x00,
      params: [toUint8((id >> 8) & 0xff), toUint8(id & 0xff), 0x00],
    });
    let response = await this.receiveReport();
    if (response.params[0] === 0) {
      throw new Error(`Feaure with ID ${toHex(id)} not supported!`);
    }
    return response.params[0];
  }

  public async activateOnboard() {
    let featureIndex = await this.getFeatureIndex(0x8100);
    await this.sendReport(
      {
        reportId: reportId.SHORT,
        deviceIndex: this.deviceIndex,
        featureIndex: featureIndex,
        functionId: 0x02, // get onboard
        params: [0x00, 0x00, 0x00],
      }
    );
    let response = await this.receiveReport();
    if (response.params[0] !== 0x01)
    {
      await this.sendReport(
        {
          reportId: reportId.SHORT,
          deviceIndex: this.deviceIndex,
          featureIndex: featureIndex,
          functionId: 0x01, // set onboard
          params: [0x01, 0x00, 0x00],
        }
      );
      response = await this.receiveReport();
    }
  }

  public async getDeviceName(): Promise<string> {
    await this.sendReport({
      reportId: reportId.SHORT,
      deviceIndex: this.deviceIndex,
      featureIndex: 0x03,
      functionId: 0x01,
      params: [0, 0, 0],
    });
    let response: HIDpp2Report = await this.receiveReport();
    return String.fromCharCode.apply(null, response.params);
  }

  public async readPage(pageId: uint8) {
    let featureIndex = await this.getFeatureIndex(0x8100);
    let buffer: Array<uint8> = [];
    for (let i of [
      0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0,
      0xc0, 0xd0, 0xe0, 0xf0,
    ]) {
      await this.sendReport({
        reportId: reportId.LONG,
        deviceIndex: this.deviceIndex,
        featureIndex: featureIndex,
        functionId: 0x05,
        params: [0, pageId, 0, toUint8(i), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      });
      let response = await this.receiveReport();
      for (let x of response.params) buffer.push(x);
    }
    return buffer;
  }

  public async writePage(pageId: uint8, buffer: Array<uint8>) {
    let featureIndex = await this.getFeatureIndex(0x8100);
    if (buffer.length !== this.pageSize)
      throw new Error(`Buffer size must be equal to page size!`);
    
      // add crc
    // let crc = crc_ccitt(buffer, buffer.length - 2);
    // buffer[buffer.length - 2] = toUint8((crc >> 4) & 0xff);
    // buffer[buffer.length - 1] = toUint8(crc & 0xff);
    
    // start transaction
    await this.sendReport({
      reportId: reportId.LONG,
      deviceIndex: this.deviceIndex,
      featureIndex: featureIndex,
      functionId: 0x06,
      params: [
        0x00, // ROM?
        pageId,
        0x00, // offset
        0x00, // offset
        this.pageSize === 256 ? 0x01: 0x00,
        this.pageSize === 256 ? 0x00: 0xff,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
      ],
    });
    await this.receiveReport();
    for (let start = 0; start < this.pageSize; start += 16) {
      await this.sendReport({
        reportId: reportId.LONG,
        deviceIndex: this.deviceIndex,
        featureIndex: featureIndex,
        functionId: 0x07,
        params: buffer.slice(start, start + 16),
      });
      await this.receiveReport();
    }
    // end transaction
    await this.sendReport({
      reportId: reportId.SHORT,
      deviceIndex: this.deviceIndex,
      featureIndex: featureIndex,
      functionId: 0x08,
      params: [0, 0, 0],
    });
    await this.receiveReport();
  }

  public async serializeMacro(macro_string: string) {
    let byte_stream: Array<uint8> = [];
    let instructions = macro_string.split("\n");
    let line_no = 0;
    for (let op of instructions) {
      op = op.trim().toUpperCase();
      if (op.startsWith("#") || op.length === 0) continue;
      let parts = op.split(" ");
      if (parts.length === 0)
        throw new Error("ERROR: at line" + line_no.toString());

      if (parts.length > 1) {
        /* Modifier(s) + Single Key */
        let index = 0;
        let modifiers = [];
        while (index < parts.length - 1) {
          modifiers.push(parseMod(parts[index]));
          index += 1;
        }

        if (
          modifiers.filter(
            (value, index, array) => array.indexOf(value) === index
          ).length !== modifiers.length
        )
          throw new Error(
            "ERROR: at line" +
              line_no.toString() +
              "\n-> modifiers must be distinct"
          );

        let mod_mask = 0x00;
        for (let modifier of modifiers) {
          mod_mask &= modifier;
        }

        // press key
        byte_stream.push(0x43);
        byte_stream.push(toUint8(mod_mask));
        byte_stream.push(toUint8(parseKey(parts[parts.length - 1])));
        // release key
        byte_stream.push(0x44);
        byte_stream.push(toUint8(mod_mask));
        byte_stream.push(toUint8(parseKey(parts[parts.length - 1])));
      } else if (parts[0] in MOD_TO_HID) {
        /* Single Modifier */
        // press mod
        byte_stream.push(0x43);
        byte_stream.push(parseMod(parts[0]));
        byte_stream.push(toUint8(parseKey(parts[0])));
        // release mod
        byte_stream.push(0x44);
        byte_stream.push(parseMod(parts[0]));
        byte_stream.push(toUint8(parseKey(parts[0])));
      } else if (parts[0] === "DELAY") {
        byte_stream.push(0x40);
        byte_stream.push(0x03);
        byte_stream.push(0x24);
      } else if (parts.length === 1) {
        /* Single Key */
        // press key
        byte_stream.push(0x43);
        byte_stream.push(0x00);
        byte_stream.push(toUint8(parseKey(parts[0])));
        // release key
        byte_stream.push(0x44);
        byte_stream.push(0x00);
        byte_stream.push(toUint8(parseKey(parts[0])));
      } else {
        throw new Error("ERROR: at line" + line_no.toString());
      }
      line_no += 1;
    }
    byte_stream.push(0xff);
    return byte_stream;
  }
}

export { HIDpp2Device };
