import { HIDppDevice } from "./Device";
import { uint8, HIDpp1Report, ProfileG500 } from "../types/types";
import {
  toUint8,
  toReportId,
  reportId,
  registerOperation,
  regOpToUint8,
  serializeProfileG500,
  MOD_TO_HID,
  parseMod,
  parseKey,
} from "../types/utils";

class HIDpp1Device extends HIDppDevice {
  private async receiveReport() {
    let [reportId, arr] = await this.receive();
    let func: HIDpp1Report = {
      reportId: toReportId(reportId),
      deviceIndex: toUint8(arr[0]),
      subId: toUint8(arr[1]),
      params: Array.from(arr.slice(2)).map((x) => toUint8(x)),
    };
    return func;
  }

  private async sendReport(func: HIDpp1Report) {
    if (
      (func.reportId === reportId.SHORT && func.params.length !== 4) ||
      (func.reportId === reportId.LONG && func.params.length !== 17)
    ) {
      throw new TypeError(
        `Parameters and reportId do not match! (Only received ${func.params.length} bytes)`
      );
    }
    await this.send(
      func.reportId,
      Uint8Array.from([func.deviceIndex, func.subId, ...func.params])
    );
  }

  private async resetSequence() {
    await this.sendReport({
      reportId: 0x10,
      deviceIndex: this.deviceIndex,
      subId: 0x80,
      params: [0xa1, 0x01, 0x00, 0x00],
    });
  }

  // https://github.com/cvuchener/g500/blob/master/doc/hidpp10.md#sending-data-to-the-internal-memory
  public async writeMemory(
    pagenumber: uint8,
    offset: uint8,
    bytes: number,
    buffer: Array<uint8>
  ) {
    await this.resetSequence();
    let sequence_number: uint8 = 0;
    // start with header and data
    await this.sendReport({
      reportId: reportId.LONG,
      deviceIndex: this.deviceIndex,
      subId: 0x90,
      params: [
        toUint8(sequence_number),
        toUint8(0x01),
        pagenumber,
        offset,
        toUint8(0),
        toUint8(0),
        toUint8((bytes >> 8) & 0xff),
        toUint8(bytes & 0xff),
        toUint8(0),
        toUint8(0),
      ].concat(
        buffer.length >= 7
          ? buffer.slice(0, 7)
          : buffer.concat(Array(16).fill(toUint8(0))).slice(0, 7)
      ),
    });
    let written = 7;
    while (written < bytes) {
      sequence_number += 1;
      let data = buffer.slice(written, written + 16);
      if (data.length !== 16) {
        data = data.concat(Array(16).fill(toUint8(0)));
        data = data.slice(0, 16);
        written += data.length;
      } else written += data.length;
      await this.sendReport({
        reportId: reportId.LONG,
        deviceIndex: this.deviceIndex,
        subId: 0x91,
        params: [toUint8(sequence_number)].concat(data),
      });
    }
  }

  public async readMemory(
    pagenumber: uint8,
    offset: uint8
  ): Promise<Array<uint8>> {
    return await this.doRegisterOperation(registerOperation.READ_LONG, 0xa2, [
      pagenumber,
      offset,
      0x00,
    ]);
  }

  private async fillPage(pagenumber: uint8) {
    await this.resetSequence();
    await this.sendReport({
      reportId: reportId.LONG,
      deviceIndex: this.deviceIndex,
      subId: 0x82,
      params: ([0xa0, 0x02, 0, 0, 0, 0, 0, pagenumber] as Array<uint8>).concat(
        Array<uint8>(9).fill(0)
      ),
    });
  }

  private async doRegisterOperation(
    op: registerOperation,
    register: uint8,
    data?: Array<uint8>
  ) {
    if (data && data.length === 3) {
      await this.sendReport({
        reportId: reportId.SHORT,
        deviceIndex: this.deviceIndex,
        subId: regOpToUint8(op),
        params: [register].concat(data),
      });
    } else if (data && data.length !== 16) {
      await this.sendReport({
        reportId: reportId.LONG,
        deviceIndex: this.deviceIndex,
        subId: regOpToUint8(op),
        params: [register].concat(data),
      });
    } else if (data) {
      throw new Error("Malformed register data!");
    } else {
      await this.sendReport({
        reportId: reportId.SHORT,
        deviceIndex: this.deviceIndex,
        subId: regOpToUint8(op),
        params: [register, 0, 0, 0],
      });
    }
    let response = await this.receiveReport();
    return response.params.slice(1);
  }

  public async serializeMacro(macro_string: string) {
    let byte_stream: Array<uint8> = [];
    let instructions = macro_string.split("\n");
    let line_no = 0;
    for (let op of instructions) {
      op = op.trim().toUpperCase();
      if (op.startsWith("#") || op.length === 0) continue;
      let parts = op.split(" ");
      if (parts.length === 0)
        throw new Error("ERROR: at line" + line_no.toString());

      if (parts.length > 1) {
        /* Modifier(s) + Single Key */
        let index = 0;
        let modifiers = [];
        while (index < parts.length - 1) {
          modifiers.push(parseMod(parts[index]));
          index += 1;
        }

        if (
          modifiers.filter(
            (value, index, array) => array.indexOf(value) === index
          ).length !== modifiers.length
        )
          throw new Error(
            "ERROR: at line" +
              line_no.toString() +
              "\n-> modifiers must be distinct"
          );

        for (let modifier of modifiers) {
          // press mod
          byte_stream.push(0x22);
          byte_stream.push(modifier);
        }

        // press key
        byte_stream.push(0x20);
        byte_stream.push(toUint8(parseKey(parts[parts.length - 1])));
        // release key
        byte_stream.push(0x21);
        byte_stream.push(toUint8(parseKey(parts[parts.length - 1])));

        for (let modifier of modifiers.reverse()) {
          // release mod
          byte_stream.push(0x23);
          byte_stream.push(modifier);
        }
      } else if (parts[0] in MOD_TO_HID) {
        /* Single Modifier */
        // press mod
        byte_stream.push(0x22);
        byte_stream.push(parseMod(parts[0]));
        // release mod
        byte_stream.push(0x23);
        byte_stream.push(parseMod(parts[0]));
      } else if (parts[0] === "DELAY") {
        byte_stream.push(0xd9);
      } else if (parts.length === 1) {
        /* Single Key */
        // press key
        byte_stream.push(0x20);
        byte_stream.push(toUint8(parseKey(parts[0])));
        // release key
        byte_stream.push(0x21);
        byte_stream.push(toUint8(parseKey(parts[0])));
      } else {
        throw new Error("ERROR: at line" + line_no.toString());
      }
      line_no += 1;
    }
    byte_stream.push(0xff);
    return byte_stream;
  }

  public async loadTemporaryProfile(profile: ProfileG500) {
    let buffer = serializeProfileG500(profile);
    await this.writeMemory(0, 0, buffer.length, buffer);
    await this.loadProfileAddress(0, 0);
  }

  public async loadProfileAddress(pagenumber: uint8, offset: uint8) {
    await this.doRegisterOperation(registerOperation.WRITE_SHORT, 0x0f, [
      0x01,
      pagenumber,
      offset,
    ]);
  }

  public async setFactoryProfile() {
    await this.doRegisterOperation(
      registerOperation.WRITE_SHORT,
      0x0f,
      [0xff, 0x00, 0x00]
    );
  }

  public async getCurrentProfile() {
    return await this.doRegisterOperation(
      registerOperation.READ_SHORT,
      0x0f,
      [0x00, 0x00, 0x00]
    );
  }

  // async readPage(pagenumber : uint8) : Promise<Array<uint8>> {
  //   let pageContent = new Uint8Array(512);
  //   let read : number = 0;
  //   while (read < 512) {
  //     let buffer = await this.readMemory(pagenumber, read);

  //     read = toUint8(read)
  //   }
  //   return await
  // }
}

export { HIDpp1Device };
