import { ProfileG500, uint8 } from "./types";

function toUint8(n: number): uint8 {
  if (!Number.isInteger(n) || n < 0 || n > 255)
    throw new RangeError("Number is out of Uint8 range");
  return n as uint8;
}

function toHex(n: uint8 | number): string {
  return n.toString(16).padStart(2, "0");
}

const enum reportId {
  SHORT = 0x10,
  LONG = 0x11,
}

function toReportId(n: number): reportId {
  if (n !== 0x10 && n !== 0x11)
    throw new RangeError("Number is out of Uint8 range");
  return n as reportId;
}

const enum registerOperation {
  WRITE_SHORT = 0x80,
  READ_SHORT = 0x81,
  WRITE_LONG = 0x82,
  READ_LONG = 0x83,
}

function regOpToUint8(op: registerOperation) {
  if (registerOperation.WRITE_SHORT === op) return 0x80;
  if (registerOperation.READ_SHORT === op) return 0x81;
  if (registerOperation.WRITE_LONG === op) return 0x82;
  return 0x83; // READ_LONG
}

const enum ButtonBindingType {
  GENERIC = 0x81,
  KEYBOARD = 0x82,
  SPECIAL = 0x83,
  CONSUMER = 0x84,
  DISABLED = 0x8f,
}

function serializeProfileG500(profile: ProfileG500) {
  let buffer: Array<uint8> = [];
  buffer.push(...profile.led_color);
  buffer.push(profile.angle);
  let flat_dpi_modes = profile.dpi_modes.reduce(
    (acc, val) =>
      acc.concat([...val.x_resolution, ...val.y_resolution, ...val.led_status]),
    [] as Array<uint8>
  );
  buffer.push(...flat_dpi_modes);
  buffer.push(profile.angle_correction);
  buffer.push(profile.default_dpi_mode);
  buffer.push(profile.lift_threshold);
  buffer.push(profile.unknown);
  buffer.push(profile.usb_refresh_rate);
  let flat_button_bindings = profile.button_bindings.reduce(
    (acc, val) => acc.concat([val.type, ...val.data]),
    [] as Array<uint8>
  );
  buffer.push(...flat_button_bindings);
  return buffer;
}

// TODO: sleep is currently nop
const sleep = (ms: number) => new Promise((r) => setTimeout(r, 0));

const enum HID_MOD {
  NO = 0x00,
  CTRL = 0x01,
  SHIFT = 0x02,
  ALT = 0x04,
  WIN = 0x08,
  RCTRL = 0x10,
  RSHIFT = 0x20,
  RALT = 0x40,
  RWIN = 0x80
}

const enum HID_KEY {
  NONE = 0,
  A = 4,
  B = 5,
  C = 6,
  D = 7,
  E = 8,
  F = 9,
  G = 10,
  H = 11,
  I = 12,
  J = 13,
  K = 14,
  L = 15,
  M = 16,
  N = 17,
  O = 18,
  P = 19,
  Q = 20,
  R = 21,
  S = 22,
  T = 23,
  U = 24,
  V = 25,
  W = 26,
  X = 27,
  Y = 28,
  Z = 29,
  N1 = 30,
  N2 = 31,
  N3 = 32,
  N4 = 33,
  N5 = 34,
  N6 = 35,
  N7 = 36,
  N8 = 37,
  N9 = 38,
  N0 = 39,
  ENTER = 40,
  ESCAPE = 41,
  BSPACE = 42,
  TAB = 43,
  SPACE = 44,
  MINUS = 45,
  EQUAL = 46,
  LBRACKET = 47,
  RBRACKET = 48,
  BSLASH = 49,
  NONUS_HASH = 50,
  SCOLON = 51,
  QUOTE = 52,
  GRAVE = 53,
  COMMA = 54,
  DOT = 55,
  SLASH = 56,
  CAPSLOCK = 57,
  F1 = 58,
  F2 = 59,
  F3 = 60,
  F4 = 61,
  F5 = 62,
  F6 = 63,
  F7 = 64,
  F8 = 65,
  F9 = 66,
  F10 = 67,
  F11 = 68,
  F12 = 69,
  PSCREEN = 70,
  SCROLLLOCK = 71,
  PAUSE = 72,
  INSERT = 73,
  HOME = 74,
  PGUP = 75,
  DELETE = 76,
  END = 77,
  PGDOWN = 78,
  RIGHT = 79,
  LEFT = 80,
  DOWN = 81,
  UP = 82,
  NUMLOCK = 83,
  KP_SLASH = 84,
  KP_ASTERISK = 85,
  KP_MINUS = 86,
  KP_PLUS = 87,
  KP_ENTER = 88,
  KP_1 = 89,
  KP_2 = 90,
  KP_3 = 91,
  KP_4 = 92,
  KP_5 = 93,
  KP_6 = 94,
  KP_7 = 95,
  KP_8 = 96,
  KP_9 = 97,
  KP_0 = 98,
  KP_DOT = 99,
  NONUS_BSLASH = 100,
  APPLICATION = 101,
  POWER = 102,
  KP_EQUAL = 103,
  F13 = 104,
  F14 = 105,
  F15 = 106,
  F16 = 107,
  F17 = 108,
  F18 = 109,
  F19 = 110,
  F20 = 111,
  F21 = 112,
  F22 = 113,
  F23 = 114,
  F24 = 115,
  EXECUTE = 116,
  PASTE = 125,
  KP_LBRACKET = 182,
  KP_RBRACKET = 183,
  CTRL = 0xe0,
  SHIFT = 0xe1,
  ALT = 0xe2,
  WIN = 0xe3,
  RCTRL = 0xe4,
  RSHIFT = 0xe5,
  RALT = 0xe6,
  RWIN = 0xe7,
}
interface Dictionary<T> {
  [Key: string]: T;
}

var MOD_TO_HID: Dictionary<HID_MOD> = {
  WIN: HID_MOD.WIN,
  WINDOWS: HID_MOD.WIN,
  CMD: HID_MOD.WIN,
  GUI: HID_MOD.WIN,
  COMMAND: HID_MOD.WIN,
  CTRL: HID_MOD.CTRL,
  STRG: HID_MOD.CTRL,
  ALT: HID_MOD.ALT,
  SHIFT: HID_MOD.SHIFT,
  RCTRL: HID_MOD.RCTRL,
  RSTRG: HID_MOD.RCTRL,
  RALT: HID_MOD.RALT,
  RSHIFT: HID_MOD.RSHIFT,
};

var KEY_TO_HID: Dictionary<HID_KEY> = {
  ENTER: HID_KEY.ENTER,
  RETURN: HID_KEY.ENTER,
  ESC: HID_KEY.ESCAPE,
  ESCAPE: HID_KEY.ESCAPE,
  BACKSPACE: HID_KEY.BSPACE,
  BSPACE: HID_KEY.BSPACE,
  TAB: HID_KEY.TAB,
  SPACE: HID_KEY.SPACE,
  "-": HID_KEY.MINUS,
  "=": HID_KEY.EQUAL,
  "[": HID_KEY.LBRACKET,
  "]": HID_KEY.RBRACKET,
  "(": HID_KEY.KP_LBRACKET,
  ")": HID_KEY.KP_RBRACKET,
  "\\": HID_KEY.BSLASH,
  ";": HID_KEY.SCOLON,
  '"': HID_KEY.QUOTE,
  "`": HID_KEY.GRAVE,
  ",": HID_KEY.COMMA,
  ".": HID_KEY.DOT,
  "/": HID_KEY.SLASH,
  "#": HID_KEY.NONUS_HASH,
  CAPSLOCK: HID_KEY.CAPSLOCK,
  CAPS: HID_KEY.CAPSLOCK,
  F1: HID_KEY.F1,
  F2: HID_KEY.F2,
  F3: HID_KEY.F3,
  F4: HID_KEY.F4,
  F5: HID_KEY.F5,
  F6: HID_KEY.F6,
  F7: HID_KEY.F7,
  F8: HID_KEY.F8,
  F9: HID_KEY.F9,
  F10: HID_KEY.F10,
  F11: HID_KEY.F11,
  F12: HID_KEY.F12,
  F13: HID_KEY.F13,
  F14: HID_KEY.F14,
  F15: HID_KEY.F15,
  F16: HID_KEY.F16,
  F17: HID_KEY.F17,
  F18: HID_KEY.F18,
  F19: HID_KEY.F19,
  F20: HID_KEY.F20,
  F21: HID_KEY.F21,
  F22: HID_KEY.F22,
  F23: HID_KEY.F23,
  F24: HID_KEY.F24,
  PRINT: HID_KEY.PSCREEN,
  SCROLLLOCK: HID_KEY.SCROLLLOCK,
  PAUSE: HID_KEY.PAUSE,
  INSERT: HID_KEY.INSERT,
  HOME: HID_KEY.HOME,
  PGUP: HID_KEY.PGUP,
  DELETE: HID_KEY.DELETE,
  // "DEL": HID_KEY.DEL,
  END: HID_KEY.END,
  PGDOWN: HID_KEY.PGDOWN,
  RIGHT: HID_KEY.RIGHT,
  LEFT: HID_KEY.LEFT,
  DOWN: HID_KEY.DOWN,
  UP: HID_KEY.UP,
  "0": HID_KEY.N0,
  APPLICATION: HID_KEY.APPLICATION,
  POWER: HID_KEY.POWER,
  EXECUTE: HID_KEY.EXECUTE,
  PASTE: HID_KEY.PASTE,
  CTRL: HID_KEY.CTRL,
  SHIFT: HID_KEY.SHIFT,
  ALT: HID_KEY.ALT,
  WIN: HID_KEY.WIN,
  RCTRL: HID_KEY.RCTRL,
  RSHIFT: HID_KEY.RSHIFT,
  RALT: HID_KEY.RALT,
  RWIN: HID_KEY.RWIN,
};

function parseKey(c: string) {
  if (c in KEY_TO_HID) return KEY_TO_HID[c];
  else if (
    c.length == 1 &&
    c.charCodeAt(0) >= "A".charCodeAt(0) &&
    c.charCodeAt(0) <= "Z".charCodeAt(0)
  )
    return c.charCodeAt(0) - "A".charCodeAt(0) + HID_KEY.A;
  else if (
    c.length == 1 &&
    c.charCodeAt(0) >= "1".charCodeAt(0) &&
    c.charCodeAt(0) <= "9".charCodeAt(0)
  )
    return c.charCodeAt(0) - "1".charCodeAt(0) + HID_KEY.N1;
  else throw new Error("ERROR: cannot parse " + c);
}
function parseMod(c: string) {
  if (c in MOD_TO_HID) return MOD_TO_HID[c];
  else throw new Error("ERROR: cannot parse " + c);
}

const CRC_CCITT_SEED = 0xFFFF;
function crc_ccitt(data : Array<uint8>, length : number) {
  let crc = CRC_CCITT_SEED;
  let temp, quick;

  for (let i = 0; i < length; i++) {
    temp = (crc >> 8) ^ (data[i]);
    crc = crc << 8;
    quick = temp ^ (temp >> 4);
    crc ^= quick;
    quick = crc << 5;
    crc ^= quick;
    quick = crc << 7;
    crc ^= quick;
  }

  return crc;
}

export {
  toUint8,
  toReportId,
  reportId,
  sleep,
  registerOperation,
  regOpToUint8,
  ButtonBindingType,
  serializeProfileG500,
  toHex,
  HID_MOD,
  HID_KEY,
  KEY_TO_HID,
  MOD_TO_HID,
  parseKey,
  parseMod,
  crc_ccitt
};
